<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://th815.github.io</id>
    <title>田昊</title>
    <updated>2020-09-14T09:29:47.686Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://th815.github.io"/>
    <link rel="self" href="https://th815.github.io/atom.xml"/>
    <subtitle>记录成长点滴</subtitle>
    <logo>https://th815.github.io/images/avatar.png</logo>
    <icon>https://th815.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 田昊</rights>
    <entry>
        <title type="html"><![CDATA[Docker 和 Kubernetes 从听过到略懂：给程序员的旋风教程]]></title>
        <id>https://th815.github.io/post/docker-he-kubernetes-cong-ting-guo-dao-lue-dong-gei-cheng-xu-yuan-de-xuan-feng-jiao-cheng/</id>
        <link href="https://th815.github.io/post/docker-he-kubernetes-cong-ting-guo-dao-lue-dong-gei-cheng-xu-yuan-de-xuan-feng-jiao-cheng/">
        </link>
        <updated>2020-09-14T08:56:39.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>早在 Docker 正式发布几个月的时候，<a href="https://www.leancloud.cn/">LeanCloud</a> 就开始在生产环境大规模使用 Docker，在过去几年里 Docker 的技术栈支撑了我们主要的后端架构。这是一篇写给程序员的 Docker 和 Kubernetes 教程，目的是让熟悉技术的读者在尽可能短的时间内对 Docker 和 Kubernetes 有基本的了解，并通过实际部署、升级、回滚一个服务体验容器化生产环境的原理和好处。本文假设读者都是开发者，并熟悉 Mac/Linux 环境，所以就不介绍基础的技术概念了。命令行环境以 Mac 示例，在 Linux 下只要根据自己使用的发行版和包管理工具做调整即可。<br>
Docker 速成<br>
首先快速地介绍一下 Docker：作为示例，我们在本地启动 Docker 的守护进程，并在一个容器里运行简单的 HTTP 服务。先完成安装：</p>
<pre><code>$ brew cask install docker
</code></pre>
<p>复制代码上面的命令会从 <a href="https://brew.sh/">Homebrew</a> 安装 Docker for Mac，它包含 Docker 的后台进程和命令行工具。Docker 的后台进程以一个 Mac App 的形式安装在 /Applications 里，需要手动启动。启动 Docker 应用后，可以在 Terminal 里确认一下命令行工具的版本：</p>
<pre><code>$ docker --version
Docker version 18.03.1-ce, build 9ee9f40
</code></pre>
<p>复制代码上面显示的 Docker 版本可能和我的不一样，但只要不是太老就好。我们建一个单独的目录来存放示例所需的文件。为了尽量简化例子，我们要部署的服务是用 Nginx 来 serve 一个简单的 HTML 文件 <code>html/index.html</code>。</p>
<pre><code>$ mkdir docker-demo
$ cd docker-demo
$ mkdir html
$ echo '&lt;h1&gt;Hello Docker!&lt;/h1&gt;' &gt; html/index.html
</code></pre>
<p>复制代码接下来在当前目录创建一个叫 Dockerfile 的新文件，包含下面的内容：<br>
FROM nginx</p>
<pre><code>COPY html/* /usr/share/nginx/html
</code></pre>
<p>复制代码每个 Dockerfile 都以 <code>FROM ...</code>开头。<code>FROM nginx</code> 的意思是以 Nginx 官方提供的镜像为基础来构建我们的镜像。在构建时，Docker 会从 Docker Hub 查找和下载需要的镜像。Docker Hub 对于 Docker 镜像的作用就像 GitHub 对于代码的作用一样，它是一个托管和共享镜像的服务。使用过和构建的镜像都会被缓存在本地。第二行把我们的静态文件复制到镜像的 <code>/usr/share/nginx/html</code> 目录下。也就是 Nginx 寻找静态文件的目录。Dockerfile 包含构建镜像的指令，更详细的信息可以参考这里。<br>
然后就可以构建镜像了：</p>
<pre><code>$ docker build -t docker-demo:0.1 .
</code></pre>
<p>复制代码请确保你按照上面的步骤为这个实验新建了目录，并且在这个目录中运行 <code>docker build</code>。如果你在其它有很多文件的目录（比如你的用户目录或者 <code>/tmp</code> ）运行，docker 会把当前目录的所有文件作为上下文发送给负责构建的后台进程。<br>
这行命令中的名称<code>docker-demo</code> 可以理解为这个镜像对应的应用名或服务名，<code>0.1</code> 是标签。Docker 通过名称和标签的组合来标识镜像。可以用下面的命令来看到刚刚创建的镜像：</p>
<pre><code>$ docker image ls
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker-demo         0.1                 efb8ca048d5a        5 minutes ago       109M 
</code></pre>
<p>复制代码下面我们把这个镜像运行起来。Nginx 默认监听在 80 端口，所以我们把宿主机的 8080 端口映射到容器的 80 端口：<br>
$ docker run --name docker-demo -d -p 8080:80 docker-demo:0.1<br>
复制代码用下面的命令可以看到正在运行中的容器：</p>
<pre><code>$ docker container ps
CONTAINER ID  IMAGE            ...  PORTS                 NAMES
c495a7ccf1c7  docker-demo:0.1  ...  0.0.0.0:8080-&gt;80/tcp  docker-demo
</code></pre>
<p>复制代码这时如果你用浏览器访问 http://localhost:8080，就能看到我们刚才创建的「Hello Docker!」页面。<br>
在现实的生产环境中 Docker 本身是一个相对底层的容器引擎，在有很多服务器的集群中，不太可能以上面的方式来管理任务和资源。所以我们需要 Kubernetes 这样的系统来进行任务的编排和调度。在进入下一步前，别忘了把实验用的容器清理掉：</p>
<pre><code>$ docker container stop docker-demo
$ docker container rm docker-demo
</code></pre>
<p>复制代码安装 Kubernetes<br>
介绍完 Docker，终于可以开始试试 Kubernetes 了。我们需要安装三样东西：Kubernetes 的命令行客户端 kubctl、一个可以在本地跑起来的 Kubernetes 环境 Minikube、以及给 Minikube 使用的虚拟化引擎 xhyve。</p>
<pre><code>$ brew install kubectl
$ brew cask install minikube
$ brew install docker-machine-driver-xhyve
</code></pre>
<p>复制代码Minikube 默认的虚拟化引擎是 VirtualBox，而 xhyve 是一个更轻量、性能更好的替代。它需要以 root 权限运行，所以安装完要把所有者改为 <code>root:wheel</code>，并把 setuid 权限打开：</p>
<pre><code class="language-$">$ sudo chmod u+s /usr/local/opt/docker-machine-driver-xhyve/bin/docker-machine-driver-xhyve~~~~
复制代码然后就可以启动 Minikube 了：
~~~~$ minikube start --vm-driver xhyve~~~~
复制代码你多半会看到一个警告说 xhyve 会在未来的版本被 hyperkit 替代，推荐使用 hyperkit。不过在我写这个教程的时候 docker-machine-driver-hyperkit 还没有进入 Homebrew, 需要手动编译和安装，我就偷个懒，仍然用 xhyve。以后只要在安装和运行的命令中把 xhyve 改为 hyperkit 就可以。
如果你在第一次启动 Minikube 时遇到错误或被中断，后面重试仍然失败时，可以尝试运行 `minikube delete` 把集群删除，重新来过。
Minikube 启动时会自动配置 kubectl，把它指向 Minikube 提供的 Kubernetes API 服务。可以用下面的命令确认：

</code></pre>
<p>$ kubectl config current-context<br>
minikube</p>
<pre><code>
复制代码Kubernetes 架构简介
典型的 Kubernetes 集群包含一个 master 和很多 node。Master 是控制集群的中心，node 是提供 CPU、内存和存储资源的节点。Master 上运行着多个进程，包括面向用户的 API 服务、负责维护集群状态的 Controller Manager、负责调度任务的 Scheduler 等。每个 node 上运行着维护 node 状态并和 master 通信的 kubelet，以及实现集群网络服务的 kube-proxy。
作为一个开发和测试的环境，Minikube 会建立一个有一个 node 的集群，用下面的命令可以看到：

</code></pre>
<p>$ kubectl get nodes<br>
NAME       STATUS    AGE       VERSION<br>
minikube   Ready     1h        v1.10.0</p>
<pre><code>
复制代码部署一个单实例服务
我们先尝试像文章开始介绍 Docker 时一样，部署一个简单的服务。Kubernetes 中部署的最小单位是 pod，而不是 Docker 容器。实时上 Kubernetes 是不依赖于 Docker 的，完全可以使用其他的容器引擎在 Kubernetes 管理的集群中替代 Docker。在与 Docker 结合使用时，一个 pod 中可以包含一个或多个 Docker 容器。但除了有紧密耦合的情况下，通常一个 pod 中只有一个容器，这样方便不同的服务各自独立地扩展。
Minikube 自带了 Docker 引擎，所以我们需要重新配置客户端，让 docker 命令行与 Minikube 中的 Docker 进程通讯：
~~~~$ eval $(minikube docker-env)~~~~
复制代码在运行上面的命令后，再运行` docker image ls` 时只能看到一些 Minikube 自带的镜像，就看不到我们刚才构建的 docker-demo:0.1 镜像了。所以在继续之前，要重新构建一遍我们的镜像，这里顺便改一下名字，叫它 k8s-demo:0.1。
~~~~$ docker build -t k8s-demo:0.1 .~~~~
复制代码然后创建一个叫 pod.yml 的定义文件：
~~~~apiVersion: v1
kind: Pod
metadata:
  name: k8s-demo
spec:
  containers:
    - name: k8s-demo
      image: k8s-demo:0.1
      ports:
        - containerPort: 80~~~~
复制代码这里定义了一个叫 k8s-demo 的 Pod，使用我们刚才构建的 k8s-demo:0.1 镜像。这个文件也告诉 Kubernetes 容器内的进程会监听 80 端口。然后把它跑起来：
~~~~$ kubectl create -f pod.yml
pod &quot;k8s-demo&quot; created~~~~
复制代码kubectl 把这个文件提交给 Kubernetes API 服务，然后 Kubernetes Master 会按照要求把 Pod 分配到 node 上。用下面的命令可以看到这个新建的 Pod：
~~~~$ kubectl get pods
NAME       READY     STATUS    RESTARTS   AGE
k8s-demo   1/1       Running   0          5s~~~~
复制代码因为我们的镜像在本地，并且这个服务也很简单，所以运行` kubectl get pods `的时候 STATUS 已经是 running。要是使用远程镜像（比如 Docker Hub 上的镜像），你看到的状态可能不是 Running，就需要再等待一下。
虽然这个 pod 在运行，但是我们是无法像之前测试 Docker 时一样用浏览器访问它运行的服务的。可以理解为 pod 都运行在一个内网，我们无法从外部直接访问。要把服务暴露出来，我们需要创建一个 Service。Service 的作用有点像建立了一个反向代理和负载均衡器，负责把请求分发给后面的 pod。
创建一个 Service 的定义文件 svc.yml：
~~~~apiVersion: v1
kind: Service
metadata:
  name: k8s-demo-svc
  labels:
    app: k8s-demo
spec:
  type: NodePort
  ports:
    - port: 80
      nodePort: 30050
  selector:
    app: k8s-demo~~~~
复制代码这个 service 会把容器的 80 端口从 node 的 30050 端口暴露出来。注意文件最后两行的 selector 部分，这里决定了请求会被发送给集群里的哪些 pod。这里的定义是所有包含「app: k8s-demo」这个标签的 pod。然而我们之前部署的 pod 并没有设置标签：
~~~~$ kubectl describe pods | grep Labels
Labels:		&lt;none&gt;~~~~
复制代码所以要先更新一下 pod.yml，把标签加上（注意在 `metadata:` 下增加了 `labels `部分）：
~~~~apiVersion: v1
kind: Pod
metadata:
  name: k8s-demo
  labels:
    app: k8s-demo
spec:
  containers:
    - name: k8s-demo
      image: k8s-demo:0.1
      ports:
        - containerPort: 80~~~~
复制代码然后更新 pod 并确认成功新增了标签：
~~~~$ kubectl apply -f pod.yml
pod &quot;k8s-demo&quot; configured
$ kubectl describe pods | grep Labels
Labels:		app=k8s-demo~~~~
复制代码然后就可以创建这个 service 了：
~~~~$ kubectl create -f svc.yml
service &quot;k8s-demo-svc&quot; created~~~~
复制代码用下面的命令可以得到暴露出来的 URL，在浏览器里访问，就能看到我们之前创建的网页了。
~~~~$ minikube service k8s-demo-svc --url
http://192.168.64.4:30050~~~~
复制代码横向扩展、滚动更新、版本回滚
在这一节，我们来实验一下在一个高可用服务的生产环境会常用到的一些操作。在继续之前，先把刚才部署的 pod 删除（但是保留 service，下面还会用到）：
~~~~$ kubectl delete pod k8s-demo
pod &quot;k8s-demo&quot; deleted~~~~
复制代码在正式环境中我们需要让一个服务不受单个节点故障的影响，并且还要根据负载变化动态调整节点数量，所以不可能像上面一样逐个管理 pod。Kubernetes 的用户通常是用 Deployment 来管理服务的。一个 deployment 可以创建指定数量的 pod 部署到各个 node 上，并可完成更新、回滚等操作。
首先我们创建一个定义文件 deployment.yml：
~~~~apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: k8s-demo-deployment
spec:
  replicas: 10
  template:
    metadata:
      labels:
        app: k8s-demo
    spec:
      containers:
        - name: k8s-demo-pod
          image: k8s-demo:0.1
          ports:
            - containerPort: 80~~~~
复制代码注意开始的 `apiVersion` 和之前不一样，因为 Deployment API 没有包含在 v1 里，`replicas: 10 `指定了这个 deployment 要有 10 个 pod，后面的部分和之前的 pod 定义类似。提交这个文件，创建一个 deployment：
~~~~$ kubectl create -f deployment.yml
deployment &quot;k8s-demo-deployment&quot; created~~~~
复制代码用下面的命令可以看到这个 deployment 的副本集（replica set），有 10 个 pod 在运行。
~~~~$ kubectl get rs
NAME                             DESIRED   CURRENT   READY     AGE
k8s-demo-deployment-774878f86f   10        10        10        19s~~~~
复制代码假设我们对项目做了一些改动，要发布一个新版本。这里作为示例，我们只把 HTML 文件的内容改一下, 然后构建一个新版镜像 k8s-demo:0.2：
~~~~$ echo '&lt;h1&gt;Hello Kubernetes!&lt;/h1&gt;' &gt; html/index.html
$ docker build -t k8s-demo:0.2 .~~~~
复制代码然后更新 deployment.yml：
a~~~~piVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: k8s-demo-deployment
spec:
  replicas: 10
  minReadySeconds: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  template:
    metadata:
      labels:
        app: k8s-demo
    spec:
      containers:
        - name: k8s-demo-pod
          image: k8s-demo:0.2
          ports:
            - containerPort: 80~~~~
复制代码这里有两个改动，第一个是更新了镜像版本号 `image: k8s-demo:0.2`，第二是增加了 `minReadySeconds: 10 `和 `strategy `部分。新增的部分定义了更新策略：`minReadySeconds: 10 `指在更新了一个 pod 后，需要在它进入正常状态后 10 秒再更新下一个 pod；`maxUnavailable: 1 `指同时处于不可用状态的 pod 不能超过一个；`maxSurge: 1 `指多余的 pod 不能超过一个。这样 Kubernetes 就会逐个替换 service 后面的 pod。运行下面的命令开始更新：
~~~~$ kubectl apply -f deployment.yml --record=true
deployment &quot;k8s-demo-deployment&quot; configured~~~~
复制代码这里的 `--record=true` 让 Kubernetes 把这行命令记到发布历史中备查。这时可以马上运行下面的命令查看各个 pod 的状态：
~~~~$ kubectl get pods
NAME                                   READY  STATUS        ...   AGE
k8s-demo-deployment-774878f86f-5wnf4   1/1    Running       ...   7m
k8s-demo-deployment-774878f86f-6kgjp   0/1    Terminating   ...   7m
k8s-demo-deployment-774878f86f-8wpd8   1/1    Running       ...   7m
k8s-demo-deployment-774878f86f-hpmc5   1/1    Running       ...   7m
k8s-demo-deployment-774878f86f-rd5xw   1/1    Running       ...   7m
k8s-demo-deployment-774878f86f-wsztw   1/1    Running       ...   7m
k8s-demo-deployment-86dbd79ff6-7xcxg   1/1    Running       ...   14s
k8s-demo-deployment-86dbd79ff6-bmvd7   1/1    Running       ...   1s
k8s-demo-deployment-86dbd79ff6-hsjx5   1/1    Running       ...   26s
k8s-demo-deployment-86dbd79ff6-mkn27   1/1    Running       ...   14s
k8s-demo-deployment-86dbd79ff6-pkmlt   1/1    Running       ...   1s
k8s-demo-deployment-86dbd79ff6-thh66   1/1    Running       ...   26s~~~~
复制代码从 AGE 列就能看到有一部分 pod 是刚刚新建的，有的 pod 则还是老的。下面的命令可以显示发布的实时状态：
~~~~$ kubectl rollout status deployment k8s-demo-deployment
Waiting for rollout to finish: 1 old replicas are pending termination...
Waiting for rollout to finish: 1 old replicas are pending termination...
deployment &quot;k8s-demo-deployment&quot; successfully rolled out~~~~
复制代码由于我输入得比较晚，发布已经快要结束，所以只有三行输出。下面的命令可以查看发布历史，因为第二次发布使用了` --record=true `所以可以看到用于发布的命令。
~~~~$ kubectl rollout history deployment k8s-demo-deployment
deployments &quot;k8s-demo-deployment&quot;
REVISION	CHANGE-CAUSE
1		&lt;none&gt;
2		kubectl apply --filename=deploy.yml --record=true~~~~
复制代码这时如果刷新浏览器，就可以看到更新的内容「Hello Kubernetes!」。假设新版发布后，我们发现有严重的 bug，需要马上回滚到上个版本，可以用这个很简单的操作：
~~~~$ kubectl rollout undo deployment k8s-demo-deployment --to-revision=1
deployment &quot;k8s-demo-deployment&quot; rolled back~~~~
复制代码Kubernetes 会按照既定的策略替换各个 pod，与发布新版本类似，只是这次是用老版本替换新版本：
~~~~$ kubectl rollout status deployment k8s-demo-deployment
Waiting for rollout to finish: 4 out of 10 new replicas have been updated...
Waiting for rollout to finish: 6 out of 10 new replicas have been updated...
Waiting for rollout to finish: 8 out of 10 new replicas have been updated...
Waiting for rollout to finish: 1 old replicas are pending termination...
deployment &quot;k8s-demo-deployment&quot; successfully rolled out~~~~
复制代码在回滚结束之后，刷新浏览器就可以确认网页内容又改回了「Hello Docker!」。
结语
我们从不同层面实践了一遍镜像的构建和容器的部署，并且部署了一个有 10 个容器的 deployment, 实验了滚动更新和回滚的流程。Kubernetes 提供了非常多的功能，本文只是以走马观花的方式做了一个快节奏的 walkthrough，略过了很多细节。虽然你还不能在简历上加上「精通 Kubernetes」，但是应该可以在本地的 Kubernetes 环境测试自己的前后端项目，遇到具体的问题时求助于 Google 和官方文档即可。在此基础上进一步熟悉应该就可以在别人提供的 Kubernetes 生产环境发布自己的服务。
LeanCloud 的大部分服务都运行在基于 Docker 的基础设施上，包括各个 API 服务、中间件、后端任务等。大部分使用 LeanCloud 的开发者主要工作在前端，不过云引擎是我们的产品中让容器技术离用户最近的。云引擎提供了容器带来的隔离良好、扩容简便等优点，同时又直接支持各个语言的原生依赖管理，为用户免去了镜像构建、监控、恢复等负担，很适合希望把精力完全投入在开发上的用户。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一份简明的 Base64 原理解析]]></title>
        <id>https://th815.github.io/post/base64/</id>
        <link href="https://th815.github.io/post/base64/">
        </link>
        <updated>2020-09-13T13:05:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-base64-是什么">1. Base64 是什么</h2>
<blockquote>
<p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2^6=64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节可由 4 个可打印字符来表示。</p>
<p>——维基百科</p>
</blockquote>
<p>它不是一种加解密技术，是一种简单的编解码技术。</p>
<p>Base64 常用于表示、传输、存储二进制数据，也可以用于将一些含有特殊字符的文本内容编码，以便传输。</p>
<p>比如：</p>
<ol>
<li>
<p>在电子邮件的传输中，Base64 可以用来将 binary 的字节序列，比如附件，编码成 ASCII 字节序列；</p>
</li>
<li>
<p>将一些体积不大的图片 Base64 编码后，直接内嵌到网页源码里；</p>
</li>
<li>
<p>将要传递给 HTTP 请求的参数做简单的转换，降低肉眼可读性；</p>
<p><em>注：用于 URL 的 Base64 非标准 Base64，是一种变种。</em></p>
</li>
<li>
<p>网友们在论坛等公开场合习惯将邮箱地址 Base64 后再发出来，防止被爬虫抓取后发送垃圾邮件。</p>
</li>
</ol>
<h2 id="2-base64-编码原理">2. Base64 编码原理</h2>
<p>标准 Base64 里的 64 个可打印字符是 <code>A-Za-z0-9+/</code>，分别依次对应索引值 0-63。索引表如下：</p>
<figure data-type="image" tabindex="1"><img src="/images/posts/java/base64-index.png" alt="" loading="lazy"></figure>
<p>编码时，每 3 个字节一组，共 8bit*3=24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值，划分如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="/images/posts/java/base64-split.png" alt="" loading="lazy"></figure>
<p>这样可能不太直观，举个例子就容易理解了。比如我们对 <code>cat</code> 进行编码：</p>
<figure data-type="image" tabindex="3"><img src="/images/posts/java/base64-example.jpeg" alt="" loading="lazy"></figure>
<p>可以看到 <code>cat</code> 编码后变成了 <code>Y2F0</code>。</p>
<p>如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。</p>
<p>如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个 <code>=</code>：</p>
<figure data-type="image" tabindex="4"><img src="/images/posts/java/base64-padding2.png" alt="" loading="lazy"></figure>
<p>如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个 <code>=</code>：</p>
<figure data-type="image" tabindex="5"><img src="/images/posts/java/base64-padding1.png" alt="" loading="lazy"></figure>
<h2 id="3-实现一个简易的-base64-编码器">3. 实现一个简易的 Base64 编码器</h2>
<p>讲完原理，我们就可以动手实现一个简易的标准 Base64 编码器了，以下是我参考 Java 8 的 java.util.Base64 乱写的一个 Java 版本，仅供参考，主要功能代码如下：</p>
<pre><code class="language-java">public class CustomBase64Encoder {

    /**
     * 索引表
     */
    private static final char[] sBase64 = {
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
            'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
            'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
            'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
            'w', 'x', 'y', 'z', '0', '1', '2', '3',
            '4', '5', '6', '7', '8', '9', '+', '/'
    };

    /**
     * 将 byte[] 进行 Base64 编码并返回字符串
     * @param src 原文
     * @return 编码后的字符串
     */
    public static String encode(byte[] src) {
        if (src == null) {
            return null;
        }

        byte[] dst = new byte[(src.length + 2) / 3 * 4];

        int index = 0;

        // 每次将 3 个字节编码为 4 个字节
        for (int i = 0; i &lt; (src.length / 3 * 3); i += 3) {
            int bits = (src[i] &amp; 0xff) &lt;&lt; 16 | (src[i + 1] &amp; 0xff) &lt;&lt; 8 | (src[i + 2] &amp; 0xff);
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 18) &amp; 0x3f];
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];
            dst[index++] = (byte) sBase64[bits &amp; 0x3f];
        }

        // 处理剩下的 1 个或 2 个字节
        if (src.length % 3 == 1) {
            int bits = (src[src.length - 1] &amp; 0xff) &lt;&lt; 4;
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];
            dst[index++] = (byte) sBase64[bits &amp; 0x3f];
            dst[index++] = '=';
            dst[index] = '=';
        } else if (src.length % 3 == 2) {
            int bits = (src[src.length - 2] &amp; 0xff) &lt;&lt; 10 | (src[src.length - 1] &amp; 0xff) &lt;&lt; 2;
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 12) &amp; 0x3f];
            dst[index++] = (byte) sBase64[(bits &gt;&gt;&gt; 6) &amp; 0x3f];
            dst[index++] = (byte) sBase64[bits &amp; 0x3f];
            dst[index] = '=';
        }

        return new String(dst);
    }
}
</code></pre>
<h2 id="4-其它知识点">4. 其它知识点</h2>
<h3 id="41-为什么有的编码结果带回车">4.1 为什么有的编码结果带回车</h3>
<p>在电子邮件中，根据 RFC 822 规定，每 76 个字符需要加上一个回车换行，所以有些编码器实现，比如 sun.misc.BASE64Encoder.encode，是带回车的，还有 java.util.Base64.Encoder.RFC2045，是带回车换行的，每行 76 个字符。</p>
<h3 id="42-base64-的变种">4.2 Base64 的变种</h3>
<p>除了标准 Base64 之外，还有一些其它的 Base64 变种。</p>
<p>比如在 URL 的应用场景中，因为标准 Base64 索引表中的 <code>/</code> 和 <code>+</code> 会被 URLEncoder 转义成 <code>%XX</code> 形式，但 <code>%</code> 是 SQL 中的通配符，直接用于数据库操作会有问题。此时可以采用 URL Safe 的编码器，索引表中的 <code>/+</code> 被换成 <code>-_</code>，比如 java.util.Base64.Encoder.RFC4648_URLSAFE 就是这样的实现。</p>
<h2 id="5-参考链接">5. 参考链接</h2>
<ul>
<li><a href="https://zh.wikipedia.org/zh-hans/Base64">https://zh.wikipedia.org/zh-hans/Base64</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576">https://www.liaoxuefeng.com/wiki/897692888725344/949441536192576</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[⌚️文字图片测试]]></title>
        <id>https://th815.github.io/post/2020-09-12/</id>
        <link href="https://th815.github.io/post/2020-09-12/">
        </link>
        <updated>2020-09-12T08:09:15.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎来到<strong>田昊</strong>的个人小站 ！<br>
✍️  <strong>tianhao.tech</strong> 一个静态页面的博客，我用它来记录生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎来到<strong>田昊</strong>的个人小站 ！<br>
✍️  <strong>tianhao.tech</strong> 一个静态页面的博客，我用它来记录生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<h1 id="特性">特性👇</h1>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多<br>
平台<br>
🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<h2 id="图片测试">图片测试</h2>
<p><img src="https://th815.github.io/post-images/1599902337333.jpg" alt="" loading="lazy"><br>
这里应该是一张图片</p>
<ul>
<li>星号<br>
<strong>双“星号”测试</strong></li>
</ul>
<!-- more -->
<p>分隔符</p>
<pre><code>class MyClass {
  public static myValue: string;
  constructor(init: string) {
    this.myValue = init;
  }
}
import fs = require(&quot;fs&quot;);
module MyModule {
  export interface MyInterface extends Other {
    myProperty: any;
  }
}
declare magicNumber number;
myArray.forEach(() =&gt; { }); // fat arrow syntax`

</code></pre>
<h2 id="代码高亮">代码高亮</h2>
<pre><code>`class MyClass {
  public static myValue: string;
  constructor(init: string) {
    this.myValue = init;
  }
}
import fs = require(&quot;fs&quot;);
module MyModule {
  export interface MyInterface extends Other {
    myProperty: any;
  }
}
declare magicNumber number;
myArray.forEach(() =&gt; { }); // fat arrow syntax`
</code></pre>
<h2 id="居中">居中</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">钱</mi><mi mathvariant="normal">💰</mi></mrow><annotation encoding="application/x-tex">钱💰 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">钱</span><span class="mord">💰</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">测</mi><mi mathvariant="normal">试</mi></mrow><annotation encoding="application/x-tex">测试 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">测</span><span class="mord cjk_fallback">试</span></span></span></span></span></p>
<h2 id="列表测试">列表测试</h2>
<ul>
<li>列表</li>
<li>测试1</li>
<li>ver</li>
</ul>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>